//////////////////////////////////////////////////////////////////////////////////////////
//  This is a complete determination of the quartic points on X1(28)
//////////////////////////////////////////////////////////////////////////////////////////
 
/****************************************************************************** 
 Here is a summary of the argument.
 
 X_1(28) has genus 10, and rank 0.
 The torsion subgroup is [ 2, 4, 12, 936 ],
 and is generated by differences of rational points.

 There are 9 rational cusps, 3 quadratic cusps, 1 cubic cusps, and 2 sextic cusps,

 Working mod 3 we note that there are 9 F_3 points, 3 F_9 points, and 5 F_27 points, 12 F_81 points. 

 We compute that the images of the 12 F_81 points under Abel--Jacobi
 do not meet the reduction of the global torsion. Similarly with 
 combinations of the 5 F_27 points and 9 F_3 points, and combinations of the 3 F_9 points.

 Computing the inverse image of Abel-Jacobi succeeds. 

 
 
******************************************************************************/
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Equations from Sutherland
/////////////////////////////////////////////////////////////////////////////////////////////////////////


N:=28;


F := Rationals();
    A2<x,y> := AffineSpace(F,2);
    X := Curve(A2,x^2*(x + 1)^3*y^6 
        + x^2*(x + 1)^2*(x^4 + 11)*y^5
        + 3*x^2*(x + 1)*(3*x^4 - 2*x^2 + 15)*y^4
        - (5*x^8 - 28*x^6 + 42*x^4 - 84*x^2 + 1)*y^3
        - (x - 1)*(25*x^6 - 23*x^4 + 67*x^2 - 5)*y^2
        + 6*(x - 1)^5*(x + 1)^3*y
        - (x - 1)^6*(x + 1)^3);


    phi := CanonicalMap(ProjectiveClosure(X));
    Xsm := CanonicalImage(Domain(phi),phi); 
     P<[T]> := AmbientSpace(Xsm);



      //////////////////////////////////////////////////////////////////////
  // Compute the local torsion bound
  //////////////////////////////////////////////////////////////////////  

//  for p in [q : q in PrimesUpTo(40) | not q in PrimeDivisors(2*N) ] do

torsData := {@@};
  for p in [ 3, 5, 11, 13, 17, 19, 23, 29, 31, 37 ] do     
      invs := Invariants(ClassGroup(Curve(Reduction(Xsm,p))));
      torsData := torsData join {@invs@};
      <p,invs>;
  end for;

  /*
<3, [ 4, 4, 24, 936, 0 ]>
<5, [ 2, 2, 8, 8, 312, 936, 0 ]>
<11, [ 4, 4, 4, 4, 24, 4416048, 0 ]>
<13, [ 4, 12, 36, 36, 936, 2808, 0 ]>
  */

  "The rational torsion subgroup is a subgroup of", torsBound(torsData); 
//The rational torsion subgroup is a subgroup of [ 936, 24, 4, 4 ]



 ////////////////////////////////////////////////////////////////////////
  // Compute the known small degree points
  //////////////////////////////////////////////////////////////////////// 

F := Rationals();
  PP<[xx]> := PolynomialRing(F,Dimension(P)+1);
  PP := ProjectiveSpace(PP);                                         
  P1 := Curve(ProjectiveSpace(F,1));
  j1 := map<Xsm -> P1 | [xx[1],xx[3]]>;


  Pullback(j1,P1![1,0]);
  // This returns the pullback as a scheme. It is zero dimensional, and you can get the points as the components.
  cpts := Pullback(j1,P1![1,0]);
  irr := IrreducibleComponents(cpts);
  [Degree(cpt)  : cpt in irr]; 
  IsReduced(irr[1]); // its a quartic point
  RationalPoints(irr[1]);


for x in [1..#irr] do
    RationalPoints(irr[x]);
end for;



pts:=[[1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0], [0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ,
0], [0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0],[2 , -1 , 0 , 2 , 4 , -1 , -4 , 1 , -1 , 1],
[2 , 1 , 0 , -2 , 4 , 1 , -4 , -1 , -1 , 1],
[0 , -1 , 0 , 0 , -4 , -1 , -4 , -1 , 1 , 1],
[0 , 1 , 0 , 0 , -4 , 1 , -4 , 1 , 1 , 1]];


eqns2 := divisorSearch(Xsm,2,1);

eqns2:=
{@
    [
        X[8]^2 + X[10]^2,
        X[1] - 2*X[10],
        X[2] - X[8],
        X[3] + 2*X[10],
        X[4] + 2*X[8],
        X[5] - 6*X[10],
        X[6] - X[8],
        X[7] + 6*X[10],
        X[9] + X[10]
    ],
    [
        X[8]^2 + X[10]^2,
        X[1],
        X[2] + X[8],
        X[3],
        X[4],
        X[5] - 6*X[10],
        X[6] - X[8],
        X[7] + 6*X[10],
        X[9] + X[10]
    ],
    [
        X[8]^2 + X[10]^2,
        X[1] + 2*X[10],
        X[2] - X[8],
        X[3],
        X[4] - 2*X[8],
        X[5] + 6*X[10],
        X[6] + X[8],
        X[7] + 6*X[10],
        X[9] - X[10]
    ]
@};

// Use these points and degree 2 divisors to generate the torsion
p := 3;
  Cp<[X]> := Curve(Reduction(Xsm,p));
   Rp := Parent(X[1]);
  basePt  := Divisor(Cp![0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0]);
    pic, mPic := ClassGroup(Cp);    
    idealsHp := {@[Rp!e : e in eqns2[i] ] : i in [1,2,3]@};
    divsHp   := {@Divisor(Cp,Scheme(Cp,I)) : I in idealsHp@};
    divs := {@
         &+Places(Cp!pt) - Degree(&+Places(Cp!pt))*basePt
         : pt in pts @} ;  
    totaldivs:=divsHp join divs;
    
  global, mGlobal := sub<pic | [(Inverse(mPic))(D - Degree(D)*basePt) : D in totaldivs]>;
     Invariants(global);   
//[ 2, 4, 12, 936 ]


"There are", [#Places(Cp,i) : i in [1..4]], "places of degree 1, 2, 3, and \
4 over F_3";
//There are [ 9, 3, 5, 12 ] places of degree 1, 2, 3, and 4 over F_3
//9 ratinoal cusps lift



 //////////////////////////////////////////////////////////////////////
  // Compute the image of Abel--Jacobi mod 3, quartic
  //////////////////////////////////////////////////////////////////////  
   

 validQuarticImages := {@@};
  for pl in Places(Cp,4) do
      D := Divisor(pl) - Degree(pl)*basePt;
      if Inverse(mPic)(D) in global then
        validQuarticImages := 
        validQuarticImages join {@Inverse(mPic)(D)@};
      end if;
  end for;
  "The rational places all lift to Q, and",  #validQuarticImages, "of the other places (coming from a quartic point) are in the image of Abel--Jacobi";

//0

 moreValidQuarticImages := {@@};
  for p in Places(Cp, 2) do
    for q in Places(Cp, 2) do 
      D := Divisor(p) + Divisor(q) - 4*basePt;
      if Inverse(mPic)(D) in global then
        moreValidQuarticImages := 
        moreValidQuarticImages join {@Inverse(mPic)(D)@};
      end if;
    end for;
  end for;
  "There are", #moreValidQuarticImages, "of the other places (coming from two quadratics) in the image of Abel--Jacobi"; 
//6
  //should be 3 +2-1 chooes 2 = 4 choose 2 = 6 yay

   moreValidQuarticImages := {@@};
  for p in Places(Cp, 1) do
    for q in Places(Cp, 3) do 
      D := Divisor(p) + Divisor(q) - 4*basePt;
      if Inverse(mPic)(D) in global then
        moreValidQuarticImages := 
        moreValidQuarticImages join {@Inverse(mPic)(D)@};
      end if;
    end for;
  end for;
  "There are", #moreValidQuarticImages, "of the other places (1 rational, 1 cubic) in the image of Abel--Jacobi"; 
  //9

  //hsould be 9 choose 1 * 1 choose 1 = 9*1 yay

  moreValidQuarticImages := {@@};
  for p1 in Places(Cp, 2) do
    for p2 in Places(Cp, 1) do 
        for p3 in Places(Cp, 1) do 
              D := Divisor(p1) + Divisor(p2) + Divisor(p3) - 4*basePt;
              if Inverse(mPic)(D) in global then
                moreValidQuarticImages := 
                moreValidQuarticImages join {@Inverse(mPic)(D)@};
              end if;
        end for;
    end for;
  end for;
  "There are", #moreValidQuarticImages, "of the other places (coming from a 1 degree 2 point, 2 degree 1 points) in the image of Abel--Jacobi"; 
//135
  //should be 3(9+2-1 choose 2)= 135 yay

   moreValidQuarticImages := {@@};
  for p1 in Places(Cp, 1) do
    for p2 in Places(Cp, 1) do 
        for p3 in Places(Cp, 1) do 
            for p4 in Places(Cp, 1) do 
              D := Divisor(p1) + Divisor(p2) + Divisor(p3) + Divisor(p4) - 4*basePt;
              if Inverse(mPic)(D) in global then
                moreValidQuarticImages := 
                moreValidQuarticImages join {@Inverse(mPic)(D)@};
              end if;
            end for;
        end for;
    end for;
  end for;
  "There are", #moreValidQuarticImages, "of the other places (coming from a 4 degree 1 points) in the image of Abel--Jacobi"; 
//495
//shoudd be 9 +4-1 choose 4 = 495


